# Sample appveyor.yml to deploy artifacts to EC2 instances.

# Rust needs at least Visual Studio 2013 Appveyor OS for MSVC targets.
os: Visual Studio 2015

# Setup some encrypted keys for AWS access etc.
environment:
  aws_id:
    secure: Y7Y8RtcP7vFH/IFMO+zsouVOwOijq2NxmUhSz+dnEHU=
  aws_key: 
    secure: Vp0uxHxQJVBJvpiE5N+uRI5kFLdGfiUrc7W8BtT8sJrtzC8wtRxE7vRJlT02R5Q5
  av_api_token:
    secure: ZLG9RkD/zj44wLjq0rQzE4+zuRORhwCGd5TPR/xJd9w=
  payload:
    secure: vhhT2Vk2L6FD6ARS0mXVJGYbh86AHB+ZhRFmwfud13pLE07LTS0vHCXlpyhf3NGb7hnqgbWReA2Bro7GI2thBID1AXjP1xfoINMCulXxKZNXycTBcZz08Q/+/3als+ocSwUs2OAGZyb1lEA9D+mYtfaQTiTgMGffJ150dDSZFFN0BfU2gJuuzYgFS41YllZUpk9JY87A3FfM/KYY73qrPt+r0zQT8TxlwW6xpQaLyk1q6xLLrFYM9Izvn8QAVhJfIxXVzNnjSpWdLTILD40VyYypvhLEYkYPhN2RLuwHDZiCONQFUHz9xgsvhYhzXffFfRNeJcL4SJaMyCOP0qFI1FSY2IVFZ0gL3h02IbQ9GgfnhDNCHM4foWtQqYjCc9cAVjdmWh8FYyH/7T/+d52RTXcfBlBa1iNWKe4aJCv2Iqg6M1Uuv4syQpqzmLqncbe4lIIdubjfNK61fOcwEEvy0A+WWr+r+bQgkP7nuViGucZnnLqq4axNJVGIYU97I4S/OCVnk5nBCu0uO7fY6oK/m+b/gr5Dh7j0aZF0CCFgolI=
  matrix:
    - channel: stable
      target: x86_64-pc-windows-msvc

# Install the rust versions required by the matrix.
install:
- ps: .\appveyor_rust_install.ps1

## Build Script ##

# 'cargo test' takes care of building for us, so disable Appveyor's build stage. This prevents
# the "directory does not contain a project or solution file" error.
build: false

# Run some tests
test_script:
  - cmd: cargo test --verbose

after_test:
  - cmd: cargo build --release # build release
  - cmd: 7z a wol.zip target\release\wol.exe # zip it up

artifacts:
  # upload our archive as an artifact so it is available to deploy
  - path: wol.zip
    name: wol

before_deploy:
    # Install AWS client for PS.
  - cmd: choco install awstools.powershell
    # Set AWS credentials, send run instance request for each AMI we want and record the instance ID.
  - ps: >-
      $awsAmis = @("ami-f6ef7185", "ami-8fed73fc",  "ami-12e87661");
      $runningEc2 = New-Object System.Collections.ArrayList;

      Set-AWSCredentials -AccessKey $env:aws_id -SecretKey $env:aws_key -StoreAs default;

      Echo "Launching EC2 instances...";
      foreach ($ami in $awsAmis) {
          $instid = New-EC2Instance `
              -Region eu-west-1 `
              -ImageId $ami `
              -MinCount 1 `
              -MaxCount 1 `
              -KeyName Default `
              -InstanceType t2.micro `
              -UserData $env:payload | Select -Exp instances;
          $runningEc2.Add($instid[0].instanceid);
      };
    # Wait until total running instances with IDs matching those launched and status ok equals the number of instances launched.
  - ps: >-
      Echo "Waiting for all deployment instances to enter the running state...";
      $upSleep = 30;
      while ((Get-EC2InstanceStatus -Region eu-west-1 |
            Where { $_.InstanceId -In $runningEc2 } |
            Select -Exp Status |
            Select -Exp Status |
            Select -Exp Value |
            Group |
            Where { $_.Name -eq "ok" } |
            Select -Exp Count) -ne $runningEc2.Count) {
          Echo "Not all instances have completed spin up, sleeping for $upSleep...";
          Start-Sleep -s $upSleep;
      };
      Echo "Done!";

# This process is async to the rest of the build, don't expect a failed deploy to fail the build.
deploy:
    # Deploy using the Appveyor Agent installed on each EC2 instance.
  - provider: Environment
    name: Ec2
    on: 
      branch: master

# Cleanup our EC2 instances. Loop and sleep until they all disappear from instance status.
#
# Wait and query REST API for deployment status.
#
# ToDo:
# 1. Get the deployment id of the current build via REST API call.
# 2. Loop until we get a success or failure from the REST API.
# 3. If we fail then notify (slack) and break out of the loop.
# 4. If we succeed deploy to S3 using AWS Powershell and notify (slack) and break.
# 5. Cleanup running EC2 instances (done).
# 6. Finish up.
#
# Stuff that will be useful:
# Write-S3Object -BucketName foo -File bar;
# Invoke-RestMethod -Uri foo -Headers bar - Method baz;
# Loop and check deployment status, sleeping every 5 seconds.
#
# Notes:
# 1. The REST API bearer token will need encrypting and adding to this file.
# 2. The IAM identity used by AWS Powershell will need access to some S3 functionality.
# 3. It may be a good idea to encrypt the S3 bucket name as they are not namespaced.
# 4. Notification will probably need to be sent directly from here with a Powershell Slack library.
after_deploy:
  - ps: >-
      $headers = @{
          "Authorization" = "Bearer $token"
          "Content-type" = "application/json"
      };

      Echo $env.APPVEYOR_BUILD_ID;
      Echo $env.APPVEYOR_BUILD_NUMBER;
      Echo $env.APPVEYOR_BUILD_VERSION;

      Echo "Killing deployment instances...";
      $downSleep = 5;
      foreach ($running in $runningEc2) {
          Remove-EC2Instance -Region eu-west-1 -InstanceId $running -Force;
      };
      Echo "Waiting for all deployment instances to disappear...";
      while ((Get-EC2InstanceStatus -Region eu-west-1 |
            Where { $_.InstanceId -In $runningEc2 }) -ne $null) {
          Echo "Not all instances have been terminated, sleeping for $downSleep...";
          Start-Sleep -s $downSleep;
      };
      Echo "done!";
